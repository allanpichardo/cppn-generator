import os

import torch
from torch import nn

from models import CPPN


class ShaderWriter:

    def __init__(self, model: nn.Module, language='hlsl', output_length=3):
        params = {}
        for name, value in model.named_parameters():
            name_parts = name.split('.')
            metric = name_parts[-1]
            layer = name_parts[-2]
            if layer not in params.keys():
                params[layer] = {metric: value.data.numpy()}
            else:
                params[layer].update({metric: value.data.numpy()})

        self.parameters = params
        self.language = language
        self.output_length = output_length
        self.positional_encoding_bins = model.positional_encoding_bins

    def write_file(self, file_path: str):
        z_length = self.parameters['input_layer']['weight'].shape[1] - self.positional_encoding_bins * 4

        lines = [
            "/**\n",
            " * CPPN shader auto-generated by MHz\n",
            " */\n",
            "\n",
            "\n",
            f"float4 cppn(float2 texCoord, float z[{z_length}]) {{" if self.language == 'hlsl' else f"vec4 cppn(vec2 texCoord, float z[{z_length}]) {{",
            "\n",
            "\n",
            "\t// ---Layer 0---",
            "\n"
        ]

        input_line = f"\tconst float inputs0[{z_length + 2}] = {{texCoord.x, texCoord.y" if self.language == 'hlsl' else f"\tfloat inputs0[{z_length + 2}] = float[](texCoord.x, texCoord.y"
        for i in range(z_length):
            input_line += f", z[{i}]"
        input_line += "};\n" if self.language == 'hlsl' else ");\n"

        lines.append(input_line)

        final_calculation = 0
        for i, layer in enumerate(self.parameters):
            w = self.parameters[layer]['weight']
            b = self.parameters[layer]['bias']

            input_dim = w.shape[0]
            output_dim = w.shape[1]
            bias_dim = b.shape[0]

            w = w.tolist()
            b = b.tolist()

            weight_line = f"\tconst float weights{i}[{input_dim}][{output_dim}] = {{\n" if self.language == 'hlsl' else ""
            weight_literal = []
            for j in range(input_dim):
                weight_literal.append(
                    f"\t\t\t{{{', '.join(str(x) for x in w[j])}}}" if self.language == 'hlsl' else f"\tfloat weights{i}_{j}[{output_dim}] = float[]({', '.join(str(x) for x in w[j])});")
            weight_line += ",\n".join(weight_literal) if self.language == 'hlsl' else "\n".join(weight_literal)
            weight_line += "\n\t};\n" if self.language == 'hlsl' else "\n"
            lines.append(weight_line)

            bias_line = f"\tconst float bias{i}[{bias_dim}] = {{{', '.join(str(x) for x in b)}}};\n\n" if self.language == 'hlsl' else f"\tfloat bias{i}[{bias_dim}] = float[]({', '.join(str(x) for x in b)});\n\n"
            lines.append(bias_line)

            lines.append(f"\t// ---Layer {i + 1}---\n")

            output_line = f"\tfloat inputs{i + 1}[{input_dim}] = {{" if self.language == 'hlsl' else f"\tfloat inputs{i + 1}[{input_dim}] = float[]("
            output_literal = []
            for j in range(input_dim):
                computations = []
                for k in range(output_dim):
                    computations.append(f"inputs{i}[{k}]*weights{i}_{j}[{k}]")
                output_literal.append(f"\n\t\t{' + '.join(computations)}")
            output_line += ", ".join(output_literal)
            output_line += "\n\t};\n" if self.language == 'hlsl' else ");\n"
            lines.append(output_line)

            for j in range(input_dim):
                if i + 1 < len(self.parameters):
                    lines.append(f"\tinputs{i + 1}[{j}] = tanh(inputs{i + 1}[{j}] + bias{i}[{j}]);\n")
                else:
                    lines.append(f"\tinputs{i + 1}[{j}] = smoothstep(0.0, 1.0, inputs{i + 1}[{j}] + bias{i}[{j}]);\n")

            final_calculation = i + 1

        lines.append("\n")
        if self.output_length == 1:
            lines.append(
                f"\treturn float4(inputs{final_calculation}[0], inputs{final_calculation}[0], inputs{final_calculation}[0], 1.0);\n" if self.language == 'hlsl' else f"\treturn vec4(inputs{final_calculation}[0], inputs{final_calculation}[0], inputs{final_calculation}[0], 1.0);\n")
        if self.output_length == 3:
            lines.append(
                f"\treturn float4(inputs{final_calculation}[0], inputs{final_calculation}[1], inputs{final_calculation}[2], 1.0);\n" if self.language == 'hlsl' else f"\treturn vec4(inputs{final_calculation}[0], inputs{final_calculation}[1], inputs{final_calculation}[2], 1.0);\n")
        if self.output_length == 4:
            lines.append(
                f"\treturn float4(inputs{final_calculation}[0], inputs{final_calculation}[1], inputs{final_calculation}[2], inputs{final_calculation}[3]);\n" if self.language == 'hlsl' else f"\treturn vec4(inputs{final_calculation}[0], inputs{final_calculation}[1], inputs{final_calculation}[2], inputs{final_calculation}[3]);\n")

        lines.append("}")

        with open(file_path, "w+") as file:
            file.writelines(lines)
            file.close()


if __name__ == '__main__':
    output_length = 3
    model_save_path = "model.pth"
    model = CPPN(input_vector_length=12, num_nodes=16, num_layers=9, output_vector_length=output_length, positional_encoding_bins=12)

    if os.path.exists(model_save_path):
        print("Found existing model, loading...")
        print("Loading model from {}".format(model_save_path))
        model.load_state_dict(torch.load(model_save_path))

    shader_writer = ShaderWriter(model, language='glsl', output_length=output_length)
    shader_writer.write_file('/Users/allanpichardo/Documents/Art Documents/CPPN Visualizer/cppn.shader')
